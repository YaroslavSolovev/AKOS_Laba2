================================================================================
ПОДРОБНОЕ ОБЪЯСНЕНИЕ КОДА КЛИЕНТА (client.py)
================================================================================

Этот файл реализует клиентскую часть приложения для межпроцессного
взаимодействия через общий файл.

================================================================================
ИМПОРТЫ (строки 1-3)
================================================================================

import os
  → Модуль для работы с операционной системой
  → Используется для: проверки существования файла, удаления файла, fsync

import sys
  → Модуль для системных операций
  → Используется для: выход из программы (sys.exit)

import time
  → Модуль для работы со временем
  → Используется для: задержки (time.sleep), измерения времени (time.time)


================================================================================
КОНСТАНТЫ (строки 5-6)
================================================================================

SHARED_FILE = "shared_communication.txt"
  → Имя общего файла для взаимодействия с сервером
  → Клиент записывает запросы в этот файл
  → Сервер записывает ответы в этот файл

TIMEOUT = 10
  → Максимальное время ожидания ответа от сервера (в секундах)
  → Если за 10 секунд ответ не пришел, клиент выдаст ошибку


================================================================================
ФУНКЦИЯ: read_file() (строки 9-22)
================================================================================

def read_file():
  → Функция читает содержимое из общего файла
  → Возвращает: строку с содержимым или None если файл не существует/пуст

    """Чтение из файла"""
      → Краткое описание функции

    if not os.path.exists(SHARED_FILE):
      → Проверяем существует ли файл
      → os.path.exists() возвращает True если файл есть, False если нет

        return None
          → Если файла нет, возвращаем None

    try:
      → Начало блока обработки ошибок
      → Если что-то пойдет не так при чтении, ошибка будет перехвачена

        with open(SHARED_FILE, 'r', encoding='utf-8') as f:
          → Открываем файл для чтения ('r' = read)
          → encoding='utf-8' - кодировка для русских букв
          → with автоматически закроет файл после использования
          → f - это файловый объект

            content = f.read().strip()
              → f.read() - читаем весь файл целиком
              → .strip() - убираем пробелы и переносы строк в начале и конце
              → Сохраняем в переменную content

            return content if content else None
              → Если content не пустая строка, возвращаем её
              → Если content пустая строка (""), возвращаем None
              → Это сокращенная форма: if content: return content else: return None

    except IOError:
      → Если произошла ошибка ввода-вывода (например, нет прав на чтение)

        return None
          → Возвращаем None при ошибке


================================================================================
ФУНКЦИЯ: write_file(content) (строки 25-33)
================================================================================

def write_file(content):
  → Функция записывает содержимое в общий файл
  → Параметр content: строка для записи

    """Запись в файл"""
      → Краткое описание функции

    try:
      → Начало блока обработки ошибок

        with open(SHARED_FILE, 'w', encoding='utf-8') as f:
          → Открываем файл для записи ('w' = write)
          → 'w' - если файл существует, он будет перезаписан
          → encoding='utf-8' - кодировка для русских букв

            f.write(content + "\n")
              → Записываем content в файл
              → Добавляем перенос строки \n в конце

            f.flush()
              → Принудительно сбрасываем буфер в файл
              → Гарантирует что данные попадут в файловую систему

            os.fsync(f.fileno())
              → Принудительная синхронизация с диском
              → f.fileno() - получаем дескриптор файла
              → os.fsync() - гарантирует запись на физический диск
              → Это важно для межпроцессного взаимодействия!

    except IOError as e:
      → Если ошибка ввода-вывода, перехватываем её в переменную e

        raise IOError(f"Ошибка записи: {e}")
          → Пробрасываем ошибку выше с пояснением
          → f"..." - форматированная строка (f-string)


================================================================================
ФУНКЦИЯ: remove_file() (строки 36-42)
================================================================================

def remove_file():
  → Функция удаляет общий файл
  → Вызывается при выходе из программы для очистки

    """Удаление файла"""
      → Краткое описание функции

    try:
      → Начало блока обработки ошибок

        if os.path.exists(SHARED_FILE):
          → Проверяем существует ли файл

            os.remove(SHARED_FILE)
              → Удаляем файл с диска

    except IOError:
      → Если ошибка при удалении

        pass
          → Игнорируем ошибку (не делаем ничего)
          → Это нормально, файл может быть уже удален


================================================================================
ФУНКЦИЯ: send_request(message) (строки 45-48)
================================================================================

def send_request(message):
  → Функция отправляет запрос серверу
  → Параметр message: текст запроса (например "ping")

    """Отправка запроса"""
      → Краткое описание функции

    write_file(message)
      → Записываем сообщение в общий файл
      → Вызываем функцию write_file()

    print(f"[CLIENT] > {message}")
      → Выводим в консоль что мы отправили
      → [CLIENT] - префикс для понимания что это клиент
      → > - символ "отправка"


================================================================================
ФУНКЦИЯ: wait_response(sent_message) (строки 51-60)
================================================================================

def wait_response(sent_message):
  → Функция ожидает ответ от сервера
  → Параметр sent_message: запрос который мы отправили
  → Возвращает: ответ от сервера или None при таймауте

    """Ожидание ответа от сервера"""
      → Краткое описание функции

    start = time.time()
      → Запоминаем текущее время в секундах
      → Используется для отсчета таймаута

    while time.time() - start < TIMEOUT:
      → Цикл пока не прошло TIMEOUT секунд
      → time.time() - start = сколько секунд прошло с начала
      → Если прошло меньше 10 секунд, продолжаем цикл

        content = read_file()
          → Читаем файл (может вернуть строку или None)

        # Проверяем что содержимое изменилось
          → Комментарий: объясняет следующую строку

        if content and content != sent_message:
          → Если content не None (файл есть и не пустой)
          → И content отличается от нашего запроса
          → (это значит сервер уже записал ответ)

            return content
              → Возвращаем ответ сервера

        time.sleep(0.1)
          → Ждем 0.1 секунды перед следующей проверкой
          → Это снижает нагрузку на процессор
          → Проверяем файл 10 раз в секунду

    return None
      → Если вышли из цикла (таймаут), возвращаем None
      → Это означает что сервер не ответил


================================================================================
ФУНКЦИЯ: send_message(message) (строки 63-87)
================================================================================

def send_message(message):
  → Главная функция для отправки сообщения и получения ответа
  → Параметр message: текст сообщения для отправки
  → Возвращает: ответ сервера или None при ошибке

    """Отправка сообщения и получение ответа"""
      → Краткое описание функции

    try:
      → Начало блока обработки ошибок
      → Весь код внутри защищен от неожиданных ошибок

        # Отправка
          → Комментарий: следующая строка отправляет запрос

        send_request(message)
          → Вызываем функцию отправки запроса
          → Записывает message в файл и выводит лог

        # Ожидание ответа
          → Комментарий: следующая строка ждет ответ

        response = wait_response(message)
          → Ждем ответ от сервера
          → Передаем message чтобы не прочитать свой же запрос
          → Возвращает ответ или None

        if not response:
          → Если response = None (таймаут или ошибка)

            print("[CLIENT] Ошибка: Нет ответа от сервера")
              → Выводим сообщение об ошибке

            return None
              → Возвращаем None (неудача)

        # Проверка на ошибку от сервера
          → Комментарий: проверяем не вернул ли сервер ошибку

        if response.startswith("ERROR:"):
          → Если ответ начинается с "ERROR:"
          → .startswith() проверяет начало строки

            error_msg = response.replace("ERROR:", "").strip()
              → Убираем "ERROR:" из строки
              → .replace("ERROR:", "") заменяет на пустую строку
              → .strip() убираем пробелы
              → Получаем только текст ошибки

            print(f"[CLIENT] Ошибка: Сервер вернул {error_msg}")
              → Выводим ошибку от сервера

            return None
              → Возвращаем None (неудача)

        print(f"[CLIENT] < {response}")
          → Выводим в консоль полученный ответ
          → < - символ "получение"

        return response
          → Возвращаем ответ (успех)

    except Exception as e:
      → Ловим любую неожиданную ошибку

        print(f"[CLIENT] Ошибка: {e}")
          → Выводим текст ошибки

        return None
          → Возвращаем None (неудача)


================================================================================
ФУНКЦИЯ: main() (строки 90-123)
================================================================================

def main():
  → Главная функция программы
  → Содержит интерактивный цикл для общения с сервером

    """Главная функция для запуска клиента."""
      → Краткое описание функции

    print("=" * 60)
      → Печатаем линию из 60 знаков =
      → Для красивого оформления

    print("PING-PONG CLIENT")
      → Заголовок программы

    print("Введите 'ping' для отправки запроса")
      → Подсказка пользователю

    print("Введите 'exit' или 'quit' для выхода")
      → Инструкция как выйти

    print("=" * 60)
      → Закрывающая линия

    try:
      → Начало блока обработки ошибок
      → Весь основной код защищен

        while True:
          → Бесконечный цикл
          → Будет работать пока не введем exit

            user_input = input("\n> ").strip()
              → Ждем ввод от пользователя
              → \n - пустая строка перед приглашением
              → > - приглашение ввода
              → .strip() - убираем пробелы по краям
              → Сохраняем введенное в user_input

            # Выход
              → Комментарий: проверка команды выхода

            if user_input.lower() in ['exit', 'quit', 'q']:
              → Если пользователь ввел exit, quit или q
              → .lower() - преобразуем в нижний регистр
              → in [...] - проверяем наличие в списке

                print("Выход...")
                  → Сообщение о выходе

                break
                  → Выходим из цикла while

            # Пропуск пустых строк
              → Комментарий: если ничего не ввели

            if not user_input:
              → Если user_input пустая строка

                continue
                  → Переходим к следующей итерации цикла
                  → Пропускаем остальной код

            # Отправка сообщения
              → Комментарий: отправляем то что ввели

            send_message(user_input)
              → Вызываем функцию отправки
              → Она сама выведет результат в консоль

    except KeyboardInterrupt:
      → Если пользователь нажал Ctrl+C

        print("\n\nПрервано пользователем")
          → Сообщение о прерывании
          → \n\n - две пустые строки для красоты

    except Exception as e:
      → Если произошла любая другая ошибка

        print(f"\nОшибка: {e}")
          → Выводим текст ошибки

        sys.exit(1)
          → Выходим из программы с кодом ошибки 1
          → 0 = успех, 1 = ошибка

    finally:
      → Этот блок выполнится ВСЕГДА
      → Даже если была ошибка или нажали Ctrl+C

        remove_file()
          → Удаляем общий файл
          → Очищаем после себя


================================================================================
ТОЧКА ВХОДА (строки 122-123)
================================================================================

if __name__ == "__main__":
  → Проверка: запущен ли файл напрямую
  → __name__ == "__main__" только если запустили python client.py
  → Если файл импортирован, этот код не выполнится

    main()
      → Вызываем главную функцию


================================================================================
КАК РАБОТАЕТ КЛИЕНТ: ПОШАГОВЫЙ СЦЕНАРИЙ
================================================================================

1. ЗАПУСК:
   - Пользователь запускает: python client.py
   - Выполняется main()
   - Выводится приветствие

2. ВВОД КОМАНДЫ:
   - Программа ждет ввода: >
   - Пользователь вводит: ping

3. ОТПРАВКА:
   - send_message("ping") вызывается
   - send_request("ping") записывает "ping" в файл
   - Выводится: [CLIENT] > ping

4. ОЖИДАНИЕ:
   - wait_response("ping") начинает цикл
   - Каждые 0.1 сек читает файл
   - Ждет пока содержимое файла != "ping"

5. ПОЛУЧЕНИЕ:
   - Сервер обработал и записал "pong" в файл
   - wait_response видит что "pong" != "ping"
   - Возвращает "pong"

6. ВЫВОД:
   - send_message выводит: [CLIENT] < pong
   - Возвращается к шагу 2 (ожидание новой команды)

7. ВЫХОД:
   - Пользователь вводит: exit
   - Цикл прерывается (break)
   - finally: удаляется файл
   - Программа завершается


================================================================================
ОБРАБОТКА ОШИБОК
================================================================================

1. НЕТ ФАЙЛА:
   - read_file() вернет None
   - Это нормально, сервер еще не создал файл

2. НЕТ ОТВЕТА (ТАЙМАУТ):
   - wait_response вернет None через 10 секунд
   - send_message выведет: "Нет ответа от сервера"

3. ОШИБКА ОТ СЕРВЕРА:
   - Сервер записал "ERROR: ожидается 'ping'"
   - Клиент обнаружит "ERROR:" в начале
   - Выведет: "Сервер вернул ожидается 'ping'"

4. CTRL+C:
   - KeyboardInterrupt перехватывается
   - Выводится "Прервано пользователем"
   - finally: файл удаляется

5. НЕОЖИДАННАЯ ОШИБКА:
   - Exception перехватывает всё остальное
   - Выводится текст ошибки
   - Программа завершается с кодом 1


================================================================================
ВАЖНЫЕ ОСОБЕННОСТИ
================================================================================

1. FSYNC:
   - os.fsync() критически важен
   - Гарантирует что сервер увидит запрос
   - Без него данные могут остаться в буфере

2. ПРОВЕРКА ИЗМЕНЕНИЯ:
   - wait_response проверяет content != sent_message
   - Это гарантирует что мы читаем ОТВЕТ, а не свой запрос
   - Без этой проверки клиент прочитает "ping" вместо "pong"

3. ТАЙМАУТ:
   - Предотвращает вечное ожидание
   - Если сервер не запущен или завис
   - Клиент не зависнет навсегда

4. CLEANUP:
   - finally гарантирует удаление файла
   - Даже при ошибке или Ctrl+C
   - Файловая система остается чистой

5. ИНТЕРВАЛ ОПРОСА:
   - 0.1 секунды между проверками
   - Баланс между скоростью и нагрузкой
   - 10 проверок в секунду достаточно


================================================================================
КОНЕЦ ОБЪЯСНЕНИЯ
================================================================================
