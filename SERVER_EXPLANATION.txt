================================================================================
ПОДРОБНОЕ ОБЪЯСНЕНИЕ КОДА СЕРВЕРА (server.py)
================================================================================

Этот файл реализует серверную часть приложения для межпроцессного
взаимодействия через общий файл.

================================================================================
ИМПОРТЫ (строки 1-3)
================================================================================

import os
  → Модуль для работы с операционной системой
  → Используется для: проверки существования файла, удаления файла, fsync

import sys
  → Модуль для системных операций
  → Используется для: выход из программы (sys.exit)

import time
  → Модуль для работы со временем
  → Используется для: задержки (time.sleep)


================================================================================
КОНСТАНТЫ (строки 5-6)
================================================================================

SHARED_FILE = "shared_communication.txt"
  → Имя общего файла для взаимодействия с клиентом
  → Клиент записывает запросы в этот файл
  → Сервер записывает ответы в этот файл
  → ДОЛЖЕН СОВПАДАТЬ с клиентом!

POLL_INTERVAL = 0.1
  → Интервал проверки наличия запросов (в секундах)
  → Сервер проверяет файл каждые 0.1 сек (10 раз в секунду)
  → Баланс между скоростью отклика и нагрузкой на CPU


================================================================================
ФУНКЦИЯ: read_file() (строки 9-22)
================================================================================

def read_file():
  → Функция читает содержимое из общего файла
  → Возвращает: строку с содержимым или None если файл не существует/пуст

    """Чтение из файла"""
      → Краткое описание функции

    if not os.path.exists(SHARED_FILE):
      → Проверяем существует ли файл
      → os.path.exists() возвращает True если файл есть, False если нет

        return None
          → Если файла нет, возвращаем None
          → Это нормально - клиент еще не создал запрос

    try:
      → Начало блока обработки ошибок

        with open(SHARED_FILE, 'r', encoding='utf-8') as f:
          → Открываем файл для чтения ('r' = read)
          → encoding='utf-8' - кодировка для русских букв
          → with автоматически закроет файл

            content = f.read().strip()
              → Читаем весь файл
              → .strip() убираем пробелы и переносы строк

            return content if content else None
              → Если есть содержимое, возвращаем его
              → Если пустая строка, возвращаем None

    except IOError:
      → Если ошибка чтения (например, файл заблокирован клиентом)

        return None
          → Возвращаем None, попробуем позже


================================================================================
ФУНКЦИЯ: write_file(content) (строки 25-33)
================================================================================

def write_file(content):
  → Функция записывает содержимое в общий файл
  → Параметр content: строка для записи (ответ клиенту)

    """Запись в файл"""
      → Краткое описание функции

    try:
      → Начало блока обработки ошибок

        with open(SHARED_FILE, 'w', encoding='utf-8') as f:
          → Открываем файл для записи ('w' = write)
          → 'w' ПЕРЕЗАПИСЫВАЕТ файл (старое содержимое удаляется)
          → Это важно! Заменяем запрос ответом

            f.write(content + "\n")
              → Записываем content в файл
              → Добавляем перенос строки в конце

            f.flush()
              → Сбрасываем буфер
              → Данные из памяти идут в файловую систему

            os.fsync(f.fileno())
              → КРИТИЧЕСКИ ВАЖНО для межпроцессного взаимодействия!
              → Принудительная запись на диск
              → Гарантирует что клиент увидит ответ
              → Без этого данные могут остаться в буфере

    except IOError as e:
      → Если ошибка записи

        raise IOError(f"Ошибка записи: {e}")
          → Пробрасываем ошибку выше


================================================================================
ФУНКЦИЯ: clear_file() (строки 36-42)
================================================================================

def clear_file():
  → Функция очищает содержимое файла (записывает пустую строку)
  → Нужна чтобы подготовить файл к следующему запросу

    """Очистка файла"""
      → Краткое описание функции

    try:
      → Начало блока обработки ошибок

        with open(SHARED_FILE, 'w', encoding='utf-8') as f:
          → Открываем файл для записи

            f.write("")
              → Записываем пустую строку
              → Это очищает файл полностью

    except IOError:
      → Если ошибка

        pass
          → Игнорируем (не критично)


================================================================================
ФУНКЦИЯ: remove_file() (строки 45-51)
================================================================================

def remove_file():
  → Функция удаляет общий файл с диска
  → Вызывается при запуске и остановке сервера

    """Удаление файла"""
      → Краткое описание функции

    try:
      → Начало блока обработки ошибок

        if os.path.exists(SHARED_FILE):
          → Если файл существует

            os.remove(SHARED_FILE)
              → Удаляем файл

    except IOError:
      → Если ошибка удаления

        pass
          → Игнорируем (не критично)


================================================================================
ФУНКЦИЯ: process_request(request) (строки 54-59)
================================================================================

def process_request(request):
  → Функция обрабатывает запрос от клиента
  → Параметр request: строка запроса (например "ping")
  → Возвращает: строку ответа или выбрасывает ошибку

    """Обработка запроса"""
      → Краткое описание функции

    if request.lower() == "ping":
      → Проверяем что запрос = "ping" (в любом регистре)
      → .lower() преобразует в нижний регистр
      → "PING", "Ping", "ping" - все допустимы

        return "pong"
          → Возвращаем стандартный ответ

    else:
      → Если запрос НЕ "ping"

        raise ValueError(f"Неверный запрос: '{request}'")
          → Выбрасываем ошибку ValueError
          → Она будет перехвачена в handle_single_request


================================================================================
ФУНКЦИЯ: handle_single_request() (строки 62-104)
================================================================================

def handle_single_request():
  → Функция обрабатывает ОДИН полный цикл запрос-ответ
  → Возвращает: True если запрос был обработан, False если запросов нет
  → Это КЛЮЧЕВАЯ функция сервера!

    """Обработка одного запроса"""
      → Краткое описание функции

    try:
      → Блок обработки нормального сценария

        # Чтение запроса
          → Комментарий: читаем запрос из файла

        request = read_file()
          → Читаем файл
          → Может вернуть строку или None

        if not request:
          → Если request = None (файла нет или он пуст)

            return False
              → Возвращаем False = "нет запросов"
              → Главный цикл подождет и попробует снова

        print(f"[SERVER] < {request}")
          → Выводим полученный запрос в консоль
          → [SERVER] - префикс сервера
          → < - символ "получение"

        # Обработка
          → Комментарий: обрабатываем запрос

        response = process_request(request)
          → Вызываем функцию обработки
          → Если request="ping", вернет "pong"
          → Если другое, выбросит ValueError

        time.sleep(0.05)
          → Небольшая задержка 0.05 секунды
          → Имитирует "обработку" запроса
          → В реальном приложении здесь была бы полезная работа

        # Отправка ответа
          → Комментарий: записываем ответ

        write_file(response)
          → Записываем ответ в файл
          → ПЕРЕЗАПИСЫВАЕТ запрос клиента

        print(f"[SERVER] > {response}")
          → Выводим отправленный ответ
          → > - символ "отправка"

        # Даем клиенту время прочитать
          → Комментарий: ждем пока клиент прочитает

        time.sleep(0.2)
          → Задержка 0.2 секунды
          → Клиент должен успеть прочитать ответ
          → Иначе мы можем очистить файл раньше времени

        # Очистка файла
          → Комментарий: готовим файл к следующему запросу

        clear_file()
          → Очищаем файл
          → Готовим к следующему запросу
          → БЕЗ этого мы будем читать старый ответ

        return True
          → Возвращаем True = "запрос успешно обработан"

    except ValueError as e:
      → Если process_request выбросил ValueError
      → Это значит клиент отправил НЕ "ping"

        # Неверный запрос
          → Комментарий: обработка неверного запроса

        print(f"[SERVER] Ошибка: {e}")
          → Выводим ошибку в консоль сервера

        error_msg = "ERROR: ожидается 'ping'"
          → Формируем сообщение об ошибке для клиента
          → Клиент ищет "ERROR:" в начале строки

        try:
          → Пытаемся отправить ошибку клиенту

            write_file(error_msg)
              → Записываем ошибку в файл

            print(f"[SERVER] > {error_msg}")
              → Выводим что отправили ошибку

            time.sleep(0.2)
              → Даем клиенту время прочитать

            clear_file()
              → Очищаем файл

        except:
          → Если не получилось отправить ошибку

            pass
              → Игнорируем (не критично)

        return False
          → Возвращаем False
          → Неверный запрос не считается успешной обработкой

    except Exception as e:
      → Любая другая неожиданная ошибка

        print(f"[SERVER] Ошибка: {e}")
          → Выводим ошибку

        return False
          → Возвращаем False


================================================================================
ФУНКЦИЯ: main() (строки 107-138)
================================================================================

def main():
  → Главная функция сервера
  → Содержит главный цикл обработки запросов

    """Главная функция для запуска сервера."""
      → Краткое описание функции

    print("=" * 60)
      → Линия из 60 символов =

    print("PING-PONG SERVER")
      → Заголовок

    print("Ожидание запросов от клиента...")
      → Информация о состоянии

    print("Нажмите Ctrl+C для остановки")
      → Инструкция для пользователя

    print("=" * 60)
      → Закрывающая линия

    remove_file()
      → Удаляем файл при старте
      → Очищаем состояние от предыдущего запуска
      → Важно! Иначе можем прочитать старые данные

    requests_count = 0
      → Счетчик обработанных запросов
      → Инициализируем нулем

    try:
      → Начало блока обработки ошибок
      → Весь главный цикл защищен

        while True:
          → Бесконечный цикл
          → Сервер работает пока не нажмут Ctrl+C

            if handle_single_request():
              → Пытаемся обработать один запрос
              → Возвращает True если запрос был обработан

                requests_count += 1
                  → Увеличиваем счетчик на 1
                  → += это сокращение для: requests_count = requests_count + 1

            else:
              → Если handle_single_request вернула False
              → Это значит запросов нет

                time.sleep(POLL_INTERVAL)
                  → Ждем 0.1 секунды
                  → Не нагружаем CPU постоянными проверками
                  → Проверяем файл 10 раз в секунду

    except KeyboardInterrupt:
      → Если пользователь нажал Ctrl+C

        print("\n[SERVER] Остановка сервера...")
          → Сообщение о завершении
          → \n - пустая строка перед текстом

    except Exception as e:
      → Любая другая неожиданная ошибка

        print(f"\nОшибка: {e}")
          → Выводим текст ошибки

        sys.exit(1)
          → Выходим с кодом ошибки 1

    finally:
      → Этот блок выполнится ВСЕГДА
      → Даже если была ошибка или Ctrl+C

        remove_file()
          → Удаляем файл
          → Очищаем файловую систему

        print(f"[SERVER] Обработано запросов: {requests_count}")
          → Выводим статистику

        print("=" * 60)
        print("Сервер остановлен")
        print("=" * 60)
          → Прощальное сообщение


================================================================================
ТОЧКА ВХОДА (строки 137-138)
================================================================================

if __name__ == "__main__":
  → Проверка: запущен ли файл напрямую
  → Выполнится только если: python server.py
  → Не выполнится если файл импортирован

    main()
      → Вызываем главную функцию


================================================================================
КАК РАБОТАЕТ СЕРВЕР: ПОШАГОВЫЙ СЦЕНАРИЙ
================================================================================

1. ЗАПУСК:
   - Пользователь запускает: python server.py
   - Выполняется main()
   - Удаляется старый файл (если был)
   - Выводится приветствие
   - Начинается бесконечный цикл while True

2. ОЖИДАНИЕ ЗАПРОСА:
   - handle_single_request() вызывается
   - read_file() проверяет файл
   - Файла нет → возвращает None
   - handle_single_request возвращает False
   - Цикл: sleep(0.1)
   - Снова handle_single_request()
   - (повторяется пока клиент не создаст запрос)

3. ПОЛУЧЕНИЕ ЗАПРОСА:
   - Клиент создал файл с "ping"
   - read_file() возвращает "ping"
   - Выводится: [SERVER] < ping

4. ОБРАБОТКА:
   - process_request("ping") вызывается
   - "ping".lower() == "ping" → True
   - Возвращается "pong"
   - sleep(0.05) - имитация работы

5. ОТПРАВКА ОТВЕТА:
   - write_file("pong") перезаписывает файл
   - Теперь в файле "pong" вместо "ping"
   - Выводится: [SERVER] > pong
   - requests_count = 1

6. ОЧИСТКА:
   - sleep(0.2) - даем клиенту прочитать
   - clear_file() очищает файл
   - handle_single_request возвращает True
   - Цикл повторяется → возврат к шагу 2

7. НЕВЕРНЫЙ ЗАПРОС:
   - Клиент отправил "hello"
   - process_request("hello") выбрасывает ValueError
   - except ValueError перехватывает
   - Выводится: [SERVER] Ошибка: Неверный запрос: 'hello'
   - В файл записывается "ERROR: ожидается 'ping'"
   - Выводится: [SERVER] > ERROR: ожидается 'ping'
   - clear_file() очищает
   - Возврат к циклу

8. ОСТАНОВКА:
   - Пользователь нажимает Ctrl+C
   - KeyboardInterrupt перехватывается
   - Выводится "Остановка сервера..."
   - finally: remove_file() удаляет файл
   - Выводится статистика
   - Программа завершается


================================================================================
ОБРАБОТКА ОШИБОК
================================================================================

1. НЕТ ЗАПРОСОВ:
   - read_file() возвращает None
   - handle_single_request возвращает False
   - main() делает sleep(0.1) и пробует снова
   - Это НОРМАЛЬНЫЙ режим работы

2. НЕВЕРНЫЙ ЗАПРОС:
   - ValueError перехватывается
   - Ошибка отправляется клиенту с префиксом "ERROR:"
   - Клиент увидит ошибку и поймет что запрос неверный
   - Сервер продолжает работу

3. ОШИБКА ЧТЕНИЯ/ЗАПИСИ:
   - IOError может произойти если файл заблокирован
   - read_file вернет None → попробуем позже
   - write_file выбросит ошибку → перехватится в handle_single_request
   - Сервер продолжает работу

4. CTRL+C:
   - KeyboardInterrupt перехватывается
   - Graceful shutdown (корректное завершение)
   - finally гарантирует удаление файла
   - Выводится статистика

5. НЕОЖИДАННАЯ ОШИБКА:
   - Exception перехватывает все остальное
   - Выводится текст ошибки
   - Программа завершается с кодом 1
   - finally все равно удалит файл


================================================================================
ВАЖНЫЕ ОСОБЕННОСТИ
================================================================================

1. ВАЛИДАЦИЯ ЗАПРОСОВ:
   - Сервер принимает ТОЛЬКО "ping"
   - Любой другой запрос → ошибка клиенту
   - Строгая валидация для безопасности

2. ОЧИСТКА ФАЙЛА:
   - После каждого ответа файл очищается
   - Иначе сервер прочитает свой же ответ как новый запрос
   - clear_file() критически важна для цикла!

3. ЗАДЕРЖКИ:
   - 0.05 сек - имитация обработки
   - 0.2 сек - клиент читает ответ
   - 0.1 сек - интервал опроса при отсутствии запросов
   - Балансируют скорость и надежность

4. FSYNC:
   - os.fsync() гарантирует запись на диск
   - Без этого клиент может не увидеть ответ
   - Критично для межпроцессного взаимодействия

5. СЧЕТЧИК ЗАПРОСОВ:
   - requests_count отслеживает количество
   - Полезно для мониторинга
   - Выводится при остановке

6. CLEANUP:
   - Файл удаляется при запуске (очистка старого состояния)
   - Файл удаляется при остановке (cleanup)
   - finally гарантирует выполнение

7. ФОРМАТ ОШИБОК:
   - "ERROR: текст" - стандартный формат
   - Клиент проверяет startswith("ERROR:")
   - Единый протокол взаимодействия


================================================================================
ПРОТОКОЛ ВЗАИМОДЕЙСТВИЯ
================================================================================

НОРМАЛЬНЫЙ СЦЕНАРИЙ:
1. Клиент записывает: "ping"
2. Сервер читает: "ping"
3. Сервер обрабатывает: "ping" → "pong"
4. Сервер записывает: "pong" (ПЕРЕЗАПИСЫВАЕТ файл)
5. Клиент читает: "pong" (ждет пока содержимое != "ping")
6. Сервер очищает: "" (готовит к новому запросу)

ОШИБОЧНЫЙ СЦЕНАРИЙ:
1. Клиент записывает: "hello"
2. Сервер читает: "hello"
3. Сервер обрабатывает: ValueError!
4. Сервер записывает: "ERROR: ожидается 'ping'"
5. Клиент читает: "ERROR: ожидается 'ping'"
6. Клиент видит "ERROR:" → выводит ошибку
7. Сервер очищает: ""

ФАЙЛОВЫЕ СОСТОЯНИЯ:
- НЕТ ФАЙЛА: ожидание запроса
- "ping": запрос от клиента, сервер обрабатывает
- "pong": ответ от сервера, клиент читает
- "ERROR: ...": ошибка от сервера, клиент читает
- "": очищено, готово к новому запросу


================================================================================
ПОЧЕМУ ИМЕННО ТАК?
================================================================================

1. ПОЧЕМУ ПЕРЕЗАПИСЬ ФАЙЛА?
   - Простота: всегда одно сообщение в файле
   - Синхронизация: клиент знает когда ответ готов (содержимое изменилось)
   - Альтернатива (дописывание) требует сложной синхронизации

2. ПОЧЕМУ ОЧИСТКА ПОСЛЕ ОТВЕТА?
   - Без очистки: сервер прочитает свой "pong" как новый запрос
   - Файл должен быть пуст перед новым запросом
   - Это часть протокола

3. ПОЧЕМУ SLEEP?
   - sleep(0.05): естественная задержка, снижает race conditions
   - sleep(0.2): клиент ДОЛЖЕН успеть прочитать до очистки
   - sleep(0.1): снижает нагрузку при ожидании

4. ПОЧЕМУ ТОЛЬКО "ping"?
   - Демонстрация валидации
   - В реальном приложении была бы более сложная логика
   - Показывает как отправлять ошибки клиенту

5. ПОЧЕМУ БЕСКОНЕЧНЫЙ ЦИКЛ?
   - Сервер должен работать постоянно
   - Обрабатывает запросы пока не остановят
   - Стандартный подход для серверов


================================================================================
КОНЕЦ ОБЪЯСНЕНИЯ
================================================================================
